\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[left=2.5cm, top=2.5cm, right=2.5cm, bottom=2.5cm]{geometry}
\usepackage[spanish]{babel}
\usepackage{enumitem}
\usepackage{hyperref}


\begin{document}

% Carátula
\begin{titlepage}
    \centering
    \vspace*{3cm}
    {\Large {Introducción a los Sistemas Distribuidos (75.43)}}\\[0.5cm]
    {\Large{TP Nº1: File Transfer}}\\[1cm]
    {\large Esteban Carisimo y Juan Ignacio Lopez Pecora}\\[0.5cm]
    {\large Facultad de Ingeniería, Universidad de Buenos Aires (75.43)}\\[2cm]

    {\large \textbf{Integrantes:}}\\[0.5cm]
    {\large Daniel Agustin Marianetti - 106256}\\
    {\large Lautaro Leonel Pedrozo - 110146}\\
    {\large Patricio Perrone - 98230}\\
    {\large Ezequiel Lazarte - 108063}\\[3cm]

    {\large Fecha de entrega: 8 de mayo de 2025}
\end{titlepage}

% Índice
\tableofcontents
\newpage

\section{Introducción}
El presente trabajo práctico tiene como objetivo fundamental la creación de una aplicación de red. Para alcanzar dicha finalidad, resulta indispensable comprender cómo se comunican los procesos a través de la red y analizar el modelo de servicio que la capa de transporte le ofrece a la capa de aplicación.

El objetivo específico de este trabajo es la comprensión y la puesta en práctica de los conceptos y herramientas necesarias para la implementación de un protocolo de transferencia de datos confiable (RDT). Para lograrlo, se procederá a desarrollar una aplicación de arquitectura cliente-servidor orientada a la transferencia de archivos, contemplando las operaciones de \textbf{UPLOAD} (cliente a servidor) y \textbf{DOWNLOAD} (servidor a cliente).

La implementación de esta aplicación se realizará utilizando el \textbf{lenguaje Python} y la \textbf{librería estándar de sockets}. La comunicación entre los procesos se establecerá sobre \textbf{UDP como protocolo de capa de transporte}. Para asegurar una transferencia confiable sobre UDP, se implementarán dos versiones del protocolo RDT: \textbf{Stop \& Wait} y \textbf{Selective Repeat}. Este desarrollo permitirá explorar los principios básicos de la transferencia de datos confiable y el uso de la interfaz de sockets.

\section{Hipótesis y suposiciones realizadas}
\begin{itemize}
    \item El tamaño de mensajes enviados 1024 bytes
    
    \item Explicar diseño o elección de paquetes?
    % Otros ítems de hipótesis/suposiciones irían aquí
\end{itemize}

\section{Implementación}
Explicar la arquitectura de la aplicación, los componentes principales, y cómo se utiliza la interfaz de sockets. Detallar el protocolo de red implementado para cada operación requerida.

\subsection{Mensajes/Segmentos}
Esta subsección detalla la estructura de los diferentes tipos de segmentos que se intercambian entre el cliente y el servidor para implementar el protocolo de capa de aplicación requerido.

\subsubsection{INIT}
Este segmento se utiliza para \textbf{iniciar una operación de transferencia de archivos}. 
Se define con la siguiente estructura:
\begin{itemize}
    \item \textbf{Header}: Tiene un tamaño fijo de 2 bytes.
    \begin{itemize}
        \item \textbf{Flags} (1 Byte):
        \begin{itemize}
        \item \textbf{PADDING} (6 bits)
        \item \textbf{ACK} (1 bit)
        \item \textbf{OPCODE:} Indica el tipo de operacion a realizar durante la conexión (UPLOAD o DOWNLOAD) (1 bit)
        \item \textbf{PROTOCOL:} Indica el tipo de protocolo a utilizar durante la conexión (SW o SR) (1 bit)
        \end{itemize}

        \item \textbf{File name length:} Largo en bytes del nombre de archivo (1 Byte)
    \end{itemize}
    
    \item \textbf{Payload}
    \begin{itemize}
        \item \textbf{File name:} UTF-8 string
    \end{itemize}
    
    \item \textbf{Checksum CRC32} (4 Bytes)

\end{itemize}

\subsubsection{S\&W}
El segmento \textbf{StopAndWaitSegment} (S\&W) se utiliza para la \textbf{transferencia de datos y el control} en el protocolo RDT \textbf{Stop \& Wait}. Se define con la siguiente estructura:
\begin{itemize}
    \item \textbf{Header}: Tiene un tamaño fijo de 3 bytes.
    \begin{itemize}
        \item \textbf{Flags} (1 Byte): Contiene flags empaquetados:
        \begin{itemize}
        \item \textbf{PADDING} (5 bits)
        \item \textbf{SEQ Num:} Número de secuencia (1 bit, alternando entre 0 y 1).
        \item \textbf{ACK:} (1 bit, alternando entre 0 y 1).
        \item \textbf{EOF Num:} Indicador de fin de archivo (1 bit).
        \end{itemize}
        \item \textbf{Payload Length} (2 Bytes): Longitud en bytes del campo `payload`.
    \end{itemize}
    \item \textbf{Payload} (0 - 1017 Bytes)
    \item \textbf{Checksum CRC32} (4 Bytes)
\end{itemize}
El tamaño mínimo total de un segmento S\&W serializado (sin payload) es de 1 (header) + 2 (len payload) + 0 (payload) + 4 (CRC) = 7 bytes.

\subsubsection{SR}
El segmento \textbf{SelectiveRepeatSegment} (SR) se destina a la \textbf{transferencia de datos y el control} en el protocolo RDT \textbf{Selective Repeat}. Se define con la siguiente estructura:
\begin{itemize}
    \item \textbf{Header}:
    \begin{itemize}
        \item \textbf{SEQ Num} (2 Bytes): Número de secuencia. Permite un espacio de numeración más amplio para la ventana deslizante.
        \item \textbf{ACK Num} (2 Bytes)
        \item \textbf{Win Size} (2 Bytes): Tamaño de la ventana del receptor.
        \item \textbf{Payload Length} (2 Bytes): Longitud en bytes del campo `payload`.
    \end{itemize}
    \item \textbf{Payload}
    
    \item \textbf{Checksum CRC32} (4 Bytes)
\end{itemize}
El tamaño mínimo total de un segmento SR serializado (sin payload) es de 2 (seq) + 2 (ack) + 2 (win) + 2 (len payload) + 0 (payload) + 4 (CRC) = 12 bytes.

\subsection{Handshake?}
?

\subsection{Stop \& Wait}
Explicar funcionamiento, arquitectura.

\subsection{Selective Repeat}
Explicar funcionamiento, arquitectura.

\subsection{Servidor}
Explicar funcionamiento, arquitectura.

\section{Pruebas}
Se realizaron pruebas para comparar el rendimiento de los protocolos Stop \& Wait y Selective Repeat bajo distintas condiciones de pérdida de paquetes. Las pruebas incluyeron la transferencia de un archivo de 5.2MB simulando varios porcentajes de pérdida de paquetes (0\%, 10\%, y 20\%) utilizando Mininet para emular las condiciones de la red. Para verificar la integridad de los archivos transferidos, se realizo diff entre ambos archivos verificando que sean iguales. También se verificó en WireShark el tráfico generado, confirmando que los mensajes del protocolo seguían el formato definido.

\subsection*{Resultados}

\begin{itemize}
    \item Tiempos de transferencia para un archivo de 5.2MB con diferentes porcentajes de pérdida:
    \begin{itemize}
        \item \textbf{0\% Pérdida}:
        \begin{itemize}
            \item Selective Repeat (Upload): 2.39 segundos
            \item Selective Repeat (Download): 1.43 segundos
            \item Stop \& Wait (Upload): 4.91 segundos
            \item Stop \& Wait (Download): 4.12 segundos
        \end{itemize}
        \item \textbf{10\% Pérdida}:
        \begin{itemize}
            \item Selective Repeat (Upload): 91.16 segundos
            \item Selective Repeat (Download): 94.72 segundos
            \item Stop \& Wait (Upload): 85.67 segundos
            \item Stop \& Wait (Download): 82.33 segundos
        \end{itemize}
        \item \textbf{20\% Pérdida}:
        \begin{itemize}
            \item Selective Repeat (Upload): 213.62 segundos
            \item Selective Repeat (Download): 185.18 segundos
            \item Stop \& Wait (Upload): 200.48 segundos
            \item Stop \& Wait (Download): 200.97 segundos
        \end{itemize}
    \end{itemize}
\end{itemize}

\section{Preguntas a responder}
\subsection{Describa la arquitectura Cliente-Servidor}
La arquitectura Cliente-Servidor es un modelo de comunicación donde dos entidades principales interactúan: el cliente, que solicita servicios, y el servidor que los proporciona.

El cliente es el componente que inicia la comunicación. Su función es enviar solicitudes al servidor y recibir las respuestas adecuadas.

Por otro lado, el servidor gestiona y almacena los recursos solicitados, como bases de datos, archivos o aplicaciones. Este es quien escucha las solicitudes del cliente, las procesa y responde con la información solicitada.

La comunicación entre cliente y servidor se realiza mediante protocolos de red, siendo TCP/IP el más utilizado. Este conjunto garantiza que los datos lleguen de forma segura y ordenada. En entornos web, también se emplean protocolos como HTTP o HTTPS.

\subsection{¿Cuál es la función de un protocolo de capa de aplicación?}
La función de la capa de aplicación es permitir una comunicación eficaz y segura entre diferentes programas de aplicación dentro de una red. Para lograrlo, se utilizan protocolos específicos que definen cómo deben formatearse, enviarse, recibirse e interpretarse los mensajes entre aplicaciones.

Un protocolo de capa de aplicación establece las reglas que permiten que dos programas puedan intercambiar información correctamente, aunque estén en dispositivos distintos y en redes diferentes.

Además de facilitar la comunicación, estos protocolos aseguran que los datos lleguen de forma comprensible y estructurada.

\subsection{Detalle el protocolo de aplicación desarrollado en este trabajo}
Se explica en la sección de Implementación.

\subsection{La capa de transporte del stack TCP/IP ofrece dos protocolos: TCP y UDP. ¿Qué servicios proveen dichos protocolos? ¿Cuáles son sus características? ¿Cuándo es apropiado utilizar cada uno?}

\subsection*{TCP (Transmission Control Protocol)}

\begin{itemize}
    \item Proporciona una conexión confiable.
    \item Asegura la entrega completa, ordenada y sin duplicados de los datos.
    \item Realiza control de flujo y de congestión.
    \item Requiere el establecimiento de una conexión (handshake de tres pasos).
\end{itemize}

\textbf{Cuándo se utiliza:} cuando se necesita alta fiabilidad, como en:
\begin{itemize}
    \item Navegación web (HTTP/HTTPS)
    \item Transferencia de archivos (FTP)
    \item Correo electrónico
\end{itemize}

\subsection*{UDP (User Datagram Protocol)}

\begin{itemize}
    \item No orientado a la conexión (no requiere handshake).
    \item No garantiza entrega ni orden.
    \item Tiene menor sobrecarga y mayor velocidad que TCP.
    \item No realiza control de flujo ni de congestión.
\end{itemize}

\textbf{Cuándo se utiliza:} cuando se prioriza la velocidad sobre la fiabilidad, como en:
\begin{itemize}
    \item Video llamadas y streaming en vivo
    \item Consultas DNS
\end{itemize}


\section{Dificultades encontradas}
Las dificultades encontradas durante el proyecto incluyeron la definición de estructuras de mensajes, el manejo efectivo de timeouts, la lógica para la recuperación de pérdida de paquetes y la gestión de la ejecución concurrente en el servidor. El uso de concurrencia fue útil para manejar múltiples clientes, pero requiere un análisis cuidadoso para evitar posibles vulnerabilidades como el agotamiento de recursos.

\section{Conclusión}

La conclusión principal que obtenemos de este trabajo práctico es que efectivamente se logró crear un protocolo de transferencia de datos confiable (RDT) sobre UDP, un protocolo que por sí solo no ofrece garantías de fiabilidad. Esto se realizó mediante el desarrollo de una aplicación cliente-servidor orientada a la transferencia de archivos. Se implementaron dos mecanismos RDT sobre UDP: \textbf{Stop \& Wait} y \textbf{Selective Repeat }.

\begin{itemize}
    \item \textbf{Stop \& Wait (SW)} resultó ser más simple de implementar. Su lógica es directa, lo cual facilita su desarrollo y depuración. Es útil en redes con baja pérdida, aunque menos eficiente en términos de uso del canal.
    
    \item \textbf{Selective Repeat (SR)} tiene una implementación más compleja, dado que maneja ventanas deslizantes y múltiples paquetes en tránsito.

\end{itemize}

En las pruebas realizadas, ambos protocolos lograron cumplir su propósito fundamental: garantizar la llegada de los datos de forma confiable entre host y host, incluso en presencia de pérdidas de paquetes simuladas. Esto demuestra que, mediante un diseño adecuado en la capa de aplicación, es posible construir comunicación confiable sobre una base no confiable como UDP.

En definitiva, los protocolos desarrollados cumplieron con su objetivo: ofrecer un mecanismo robusto de transferencia de archivos, resaltando la importancia del protocolo de la capa de aplicación en garantizar la fiabilidad cuando la capa de transporte no lo hace.

\end{document}
